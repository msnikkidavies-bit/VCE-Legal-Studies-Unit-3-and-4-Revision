<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>VCE Legal Pictionary Revision</title>
    <!-- Load Tailwind CSS for modern styling -->
    <script src="https://cdn.tailwindcss.com"></script>
    <!-- Use Inter Font -->
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;600;700&display=swap" rel="stylesheet">
    <style>
        :root {
            --primary-color: #3b82f6; /* blue-500 */
            --secondary-color: #10b981; /* emerald-500 */
            font-family: 'Inter', sans-serif;
        }
        .canvas-container {
            border: 4px solid var(--primary-color);
            border-radius: 12px;
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.1);
            background-color: white;
            cursor: crosshair;
        }
        #game-canvas {
            display: block;
            width: 100%;
            height: 100%;
        }
        .btn-primary {
            @apply bg-blue-600 text-white font-bold py-2 px-4 rounded-lg shadow-lg hover:bg-blue-700 transition duration-150 ease-in-out disabled:bg-gray-400 disabled:shadow-none;
        }
        .btn-secondary {
            @apply bg-emerald-500 text-white font-bold py-2 px-4 rounded-lg shadow-lg hover:bg-emerald-600 transition duration-150 ease-in-out disabled:bg-gray-400 disabled:shadow-none;
        }
        .avatar-selected {
            box-shadow: 0 0 0 3px var(--secondary-color);
        }
    </style>
</head>
<body class="bg-gray-100 min-h-screen p-4 sm:p-8">

    
    <!-- Firebase SDK Imports -->
    <script type="module">
        import { initializeApp } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-app.js";
        import { getAuth, signInAnonymously, signInWithCustomToken, onAuthStateChanged } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-auth.js";
        import { getFirestore, setLogLevel, doc, getDoc, setDoc, updateDoc, onSnapshot, collection, query, arrayUnion, arrayRemove, getDocs, deleteDoc, where, addDoc } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-firestore.js";

        // Global Firebase variables are now SAFELY accessed here
        const appId = typeof __app_id !== 'undefined' ? __app_id : 'self-hosted-pictionary';
        const initialAuthToken = typeof __initial_auth_token !== 'undefined' ? __initial_auth_token : null;
        
        // Safety check for config string provided by the environment
        const providedConfig = typeof __firebase_config !== 'undefined' ? __firebase_config : null;
        
        // Provide a robust fallback config if running outside the environment (e.g., locally)
        const fallbackConfig = JSON.stringify({
            apiKey: "YOUR_API_KEY",
            authDomain: "your-project.firebaseapp.com",
            projectId: "your-project-id",
            storageBucket: "your-project.appspot.com",
            messagingSenderId: "123456789012",
            appId: "1:123456789012:web:abcdef1234567890"
        });

        // Use provided config if available, otherwise use the fallback
        const firebaseConfigString = providedConfig || fallbackConfig;


        let app, db, auth;
        let userId = 'loading'; // Will be updated on auth state change
        let firebaseInitialized = false; // Flag to track successful Firebase initialization

        // ----------------------------------------------------------------------
        // VCE Legal Pictionary Terms (Units 3 & 4)
        // ----------------------------------------------------------------------
        const VCE_TERMS = [
            // Key Concepts
            "Separation of Powers", "Division of Powers", "Bicameral Parliament",
            "Rule of Law", "Ultra Vires", "Referendum", "Representative Government",
            // Courts and Law-Making
            "Statutory Interpretation", "Delegated Legislation", "Judicial Precedent",
            "Ratio Decidendi", "Obiter Dicta", "Stare Decisis", "Court Hierarchy",
            // Criminal Law
            "Standard of Proof", "Burden of Proof", "Beyond Reasonable Doubt",
            "Mandatory Sentencing", "Original Jurisdiction", "Appellate Jurisdiction",
            "Plea Bargaining", "Bail", "Committal Hearing",
            // Civil Law
            "Balance of Probabilities", "Remedies", "Damages", "Injunction",
            "Mediation", "Conciliation", "Arbitration", "Vcat",
            // Cases (simplified for drawing)
            "Mabo Case (Native Title)", "Dietrich v The Queen (Legal Aid)",
            "Donoghue v Stevenson (Negligence)", "Snail in a bottle",
            "High Court of Australia", "Supreme Court of Victoria",
            "Jury Duty", "Indictable Offence", "Summary Offence",
        ];

        // ----------------------------------------------------------------------
        // GAME CLASS
        // ----------------------------------------------------------------------
        class PictionaryApp {
            constructor() {
                this.isHost = false;
                this.gameId = '';
                this.playerName = '';
                this.playerAvatar = '';
                this.gameData = {}; // Real-time game state from Firestore
                this.players = []; // Real-time player list from Firestore

                this.isDrawing = false;
                this.canvas = null;
                this.ctx = null;
                this.drawingHistory = []; // Local array to store drawing history
                this.currentStroke = [];
                this.toolSize = 5;
                this.toolColor = '#000000';
                this.guessAttempted = false; // Flag to prevent multiple successful guesses
                this.setupUI();
                this.setupFirebase();
            }

            // --- 1. SETUP ---

            setupUI() {
                document.getElementById('start-screen').style.display = 'block';
                document.getElementById('lobby-setup-screen').style.display = 'none';
                document.getElementById('lobby-screen').style.display = 'none';
                document.getElementById('game-screen').style.display = 'none';

                // Initial Screen Event Listeners (DISABLED until auth is ready)
                document.getElementById('host-btn').addEventListener('click', () => this.showLobbySetup(true));
                document.getElementById('join-btn').addEventListener('click', () => this.showLobbySetup(false));
                document.getElementById('host-btn').disabled = true;
                document.getElementById('join-btn').disabled = true;

                // Lobby Setup Screen Event Listeners
                document.getElementById('setup-back-btn').addEventListener('click', () => this.resetToStartScreen());
                document.getElementById('create-join-btn').addEventListener('click', () => this.handleLobbyAction());

                // Game Screen Event Listeners
                document.getElementById('guess-input').addEventListener('keypress', (e) => {
                    if (e.key === 'Enter') this.submitGuess();
                });
                document.getElementById('guess-btn').addEventListener('click', () => this.submitGuess());
                document.getElementById('select-term-btn').addEventListener('click', () => this.showTermSelectionModal());
                document.getElementById('stop-game-btn').addEventListener('click', () => this.stopGame());
                document.getElementById('player-auth-status').textContent = 'Connecting...';
            }

            async setupFirebase() {
                let firebaseConfig;

                try {
                    // 1. Check and parse configuration
                    if (!firebaseConfigString) {
                        this.displayError("Configuration Error: Firebase config is entirely missing.");
                        document.getElementById('player-auth-status').textContent = 'Error: No Config';
                        return;
                    }
                    
                    firebaseConfig = JSON.parse(firebaseConfigString);

                    // 2. Initialize Firebase
                    // If firebaseConfig contains placeholder keys, initialization will fail silently 
                    // and be handled by onAuthStateChanged below.
                    app = initializeApp(firebaseConfig);
                    db = getFirestore(app);
                    auth = getAuth(app);
                    setLogLevel('debug');
                    firebaseInitialized = true;

                } catch (e) {
                    console.error("Error initializing Firebase:", e);
                    this.displayError("Firebase Initialization Failed. Check your config in the HTML file.");
                    document.getElementById('player-auth-status').textContent = 'Error: Init Failed';
                    return; // Exit if initialization failed
                }

                // 3. Set up Auth State Listener and Sign In
                onAuthStateChanged(auth, async (user) => {
                    if (user) {
                        userId = user.uid;
                        console.log("Authenticated with UID:", userId);
                        
                        // Enable buttons on the start screen now that auth is ready
                        document.getElementById('host-btn').disabled = false;
                        document.getElementById('join-btn').disabled = false;
                        document.getElementById('player-auth-status').classList.remove('text-gray-500', 'text-red-500');
                        document.getElementById('player-auth-status').classList.add('text-green-600', 'font-semibold');
                        document.getElementById('player-auth-status').textContent = 'Ready!';

                        // If a lobby action was pending (e.g., clicked before auth finished)
                        if (document.getElementById('lobby-setup-screen').style.display === 'block') {
                            this.handleLobbyAction(true); // Retry action after auth
                        }

                    } else {
                        // Attempt to sign in if not already signed in
                        if (initialAuthToken) {
                            try {
                                await signInWithCustomToken(auth, initialAuthToken);
                            } catch (e) {
                                console.error("Error signing in with custom token. Attempting anonymous sign-in.", e);
                                document.getElementById('player-auth-status').textContent = 'Connecting... (Sign-in Error)';
                                await signInAnonymously(auth);
                            }
                        } else {
                            await signInAnonymously(auth);
                        }
                    }
                });
            }

            displayError(message) {
                const errorDiv = document.getElementById('error-message');
                errorDiv.textContent = message;
                errorDiv.classList.remove('hidden');
                setTimeout(() => errorDiv.classList.add('hidden'), 7000);
            }

            // --- 2. LOBBY MANAGEMENT ---

            showLobbySetup(isHost) {
                this.isHost = isHost;
                document.getElementById('start-screen').style.display = 'none';
                document.getElementById('lobby-setup-screen').style.display = 'block';

                const roleText = isHost ? 'Create New Game' : 'Join Existing Game';
                document.getElementById('setup-title').textContent = roleText;
                document.getElementById('game-id-input').placeholder = isHost ? 'Auto-generated ID' : 'Enter Game ID';
                document.getElementById('game-id-input').disabled = isHost;
                document.getElementById('create-join-btn').textContent = isHost ? 'Create & Enter Lobby' : 'Join Lobby';
                document.getElementById('player-role-display').textContent = isHost ? 'Teacher (Host)' : 'Student (Player)';

                this.renderAvatarSelection();
            }

            renderAvatarSelection() {
                const avatars = ['ðŸ§‘â€ðŸ«', 'ðŸŽ“', 'âš–ï¸', 'ðŸ›ï¸', 'ðŸ‘¨â€âš–ï¸', 'ðŸ‘©â€âš–ï¸', 'ðŸ“š', 'ðŸ§ '];
                const container = document.getElementById('avatar-selection');
                container.innerHTML = '';
                this.playerAvatar = avatars[0]; // Default avatar

                avatars.forEach(avatar => {
                    const button = document.createElement('button');
                    button.textContent = avatar;
                    button.className = `p-4 text-3xl rounded-full border-2 border-transparent hover:border-blue-500 transition duration-150 ${avatar === this.playerAvatar ? 'avatar-selected' : ''}`;
                    button.onclick = () => {
                        this.playerAvatar = avatar;
                        // Remove selection from all, add to this one
                        container.querySelectorAll('button').forEach(b => b.classList.remove('avatar-selected'));
                        button.classList.add('avatar-selected');
                    };
                    container.appendChild(button);
                });
            }

            // The 'retry' flag is used when this is called from the onAuthStateChanged listener
            async handleLobbyAction(retry = false) {
                // Since buttons on start screen are disabled until ready, this check is less critical now,
                // but kept for robustness, especially for the lobby action button.
                if (!firebaseInitialized || userId === 'loading') {
                    this.displayError("Connection not ready. Please wait a moment for the game to authenticate.");
                    return;
                }

                if (!retry) {
                    this.playerName = document.getElementById('player-name-input').value.trim();
                    this.gameId = document.getElementById('game-id-input').value.trim();
                }
                
                if (!this.playerName || !this.playerAvatar) {
                    this.displayError("Please enter your name and select an avatar.");
                    return;
                }
                
                if (this.isHost) {
                    await this.createGame();
                } else {
                    if (!this.gameId) {
                        this.displayError("Please enter the Game ID to join.");
                        return;
                    }
                    await this.tryJoinGame(this.gameId);
                }
            }

            async createGame() {
                try {
                    // Create a new document in the 'games' collection to get an auto-generated ID
                    const gameRef = doc(collection(db, `artifacts/${appId}/public/data/games`));
                    this.gameId = gameRef.id;

                    await setDoc(gameRef, {
                        hostId: userId,
                        status: 'LOBBY',
                        currentRound: 0,
                        drawerId: null,
                        correctTerm: null,
                        timerStart: null,
                        maxScore: 0,
                    });

                    await this.tryJoinGame(this.gameId);

                } catch (e) {
                    console.error("Error creating game:", e);
                    this.displayError("Failed to create game. Please check console for details.");
                }
            }

            async tryJoinGame(gameId) {
                try {
                    const gameRef = doc(db, `artifacts/${appId}/public/data/games`, gameId);
                    const gameDoc = await getDoc(gameRef);

                    if (!gameDoc.exists()) {
                        this.displayError(`Game ID "${gameId}" not found.`);
                        this.resetToStartScreen();
                        return;
                    }

                    if (gameDoc.data().status !== 'LOBBY' && !this.isHost) {
                        this.displayError("Game has already started or finished. Cannot join.");
                        this.resetToStartScreen();
                        return;
                    }

                    const playerRef = doc(db, `artifacts/${appId}/public/data/players`, userId);

                    // Add player to the game
                    await setDoc(playerRef, {
                        userId: userId,
                        gameId: gameId,
                        name: this.playerName,
                        avatar: this.playerAvatar,
                        score: 0,
                        isHost: this.isHost,
                        lastActive: Date.now()
                    });

                    this.gameId = gameId;

                    // Transition to Lobby Screen
                    document.getElementById('lobby-setup-screen').style.display = 'none';
                    document.getElementById('lobby-screen').style.display = 'block';

                    document.getElementById('lobby-game-id').textContent = gameId;

                    // Set up Firestore listeners
                    this.listenToGame(gameRef);
                    this.listenToPlayers(gameId);

                    if (this.isHost) {
                        document.getElementById('host-controls').classList.remove('hidden');
                        document.getElementById('student-info').classList.add('hidden');
                    } else {
                        document.getElementById('host-controls').classList.add('hidden');
                        document.getElementById('student-info').classList.remove('hidden');
                    }

                } catch (e) {
                    console.error("Error joining game:", e);
                    this.displayError("Failed to join game. Check console.");
                }
            }

            // --- 3. FIREBASE LISTENERS ---

            listenToGame(gameRef) {
                this.gameUnsubscribe = onSnapshot(gameRef, (doc) => {
                    if (doc.exists()) {
                        this.gameData = doc.data();
                        this.updateGameUI();
                    } else {
                        // Game deleted by host
                        this.displayError("Game was closed by the host.");
                        this.resetToStartScreen();
                    }
                });
            }

            listenToPlayers(gameId) {
                const playersQuery = query(
                    collection(db, `artifacts/${appId}/public/data/players`),
                    where('gameId', '==', gameId)
                );

                this.playersUnsubscribe = onSnapshot(playersQuery, (snapshot) => {
                    this.players = [];
                    snapshot.forEach(doc => {
                        this.players.push(doc.data());
                    });
                    // Sort by score descending, then name ascending
                    this.players.sort((a, b) => b.score - a.score || a.name.localeCompare(b.name));
                    this.renderPlayerList();
                });
            }

            listenToGuesses() {
                const guessesQuery = query(
                    collection(db, `artifacts/${appId}/public/data/guesses`),
                    where('gameId', '==', this.gameId),
                    where('round', '==', this.gameData.currentRound)
                );

                // Clear previous listener if any
                if (this.guessUnsubscribe) this.guessUnsubscribe();

                this.guessUnsubscribe = onSnapshot(guessesQuery, (snapshot) => {
                    this.renderChat(snapshot.docs.map(doc => doc.data()));
                });
            }

            listenToDrawing() {
                const drawingRef = doc(db, `artifacts/${appId}/public/data/drawings`, this.gameId);

                // Clear previous listener if any
                if (this.drawingUnsubscribe) this.drawingUnsubscribe();

                this.drawingUnsubscribe = onSnapshot(drawingRef, (doc) => {
                    if (doc.exists() && doc.data().history) {
                        this.drawingHistory = doc.data().history;
                        this.redrawCanvas();
                    } else {
                        this.drawingHistory = [];
                        this.redrawCanvas();
                    }
                });
            }

            // --- 4. GAME LOGIC & UI UPDATES ---

            updateGameUI() {
                const { status, currentRound, drawerId, correctTerm, timerStart } = this.gameData;

                if (status === 'LOBBY') {
                    if (document.getElementById('game-screen').style.display !== 'none') {
                        document.getElementById('game-screen').style.display = 'none';
                        document.getElementById('lobby-screen').style.display = 'block';
                    }
                    return;
                }

                if (document.getElementById('lobby-screen').style.display !== 'none') {
                    document.getElementById('lobby-screen').style.display = 'none';
                    document.getElementById('game-screen').style.display = 'flex';
                    this.setupCanvas();
                    this.listenToDrawing();
                }

                const isDrawer = (drawerId === userId);
                const isHost = this.isHost;

                // --- General Game State UI ---
                document.getElementById('game-info-drawer').textContent = this.players.find(p => p.userId === drawerId)?.name || '...';
                document.getElementById('game-info-round').textContent = currentRound;

                // Set up controls visibility
                document.getElementById('drawing-tools').style.display = isDrawer ? 'flex' : 'none';
                document.getElementById('guessing-area').style.display = isDrawer ? 'none' : 'flex'; // Changed to flex to match input/button
                document.getElementById('guess-input').value = ''; // Clear input on state change

                // --- Drawing Player specific UI ---
                if (isDrawer) {
                    document.getElementById('drawer-term').textContent = correctTerm ? `Drawing: ${correctTerm}` : 'Select a term to start!';
                    document.getElementById('select-term-btn').style.display = correctTerm ? 'none' : 'block';
                    document.getElementById('guess-info').style.display = 'none';
                } else {
                    // Guesser UI
                    const placeholder = correctTerm ? Array(correctTerm.length).fill('_').join(' ') : '...';
                    document.getElementById('drawer-term').textContent = `Drawing: ${placeholder}`;
                    document.getElementById('select-term-btn').style.display = 'none';
                    document.getElementById('guess-info').style.display = 'block';
                }

                // --- Host Control Visibility ---
                document.getElementById('host-game-controls').style.display = isHost ? 'block' : 'none';

                // --- Timer Management ---
                clearInterval(this.timerInterval);
                if (timerStart) {
                    this.timerInterval = setInterval(() => {
                        const elapsed = Math.floor((Date.now() - timerStart) / 1000);
                        const timeLeft = 30 - elapsed;
                        const timerDisplay = document.getElementById('timer-display');

                        if (timeLeft <= 0) {
                            clearInterval(this.timerInterval);
                            timerDisplay.textContent = 'Time Up!';
                            timerDisplay.classList.remove('text-green-600', 'text-yellow-600');
                            timerDisplay.classList.add('text-red-600');
                            if (isHost) this.handleRoundEnd(0);
                        } else {
                            timerDisplay.textContent = `Time: ${timeLeft}s`;
                            timerDisplay.classList.remove('text-red-600');
                            if (timeLeft > 15) {
                                timerDisplay.classList.add('text-green-600');
                                timerDisplay.classList.remove('text-yellow-600');
                            } else {
                                timerDisplay.classList.add('text-yellow-600');
                                timerDisplay.classList.remove('text-green-600');
                            }
                        }
                    }, 1000);

                    // Start listening to guesses once drawing starts
                    this.listenToGuesses();
                    this.guessAttempted = false; // Reset guess flag for new round

                } else if (status === 'IN_PROGRESS' && drawerId && !correctTerm) {
                    // Waiting for drawer to select a term
                    document.getElementById('timer-display').textContent = 'Awaiting selection...';
                } else if (status === 'ROUND_END') {
                    document.getElementById('timer-display').textContent = `Round ${currentRound} Ended! Term was: ${correctTerm}`;
                    document.getElementById('drawer-term').textContent = `The word was: ${correctTerm}`;
                    // Automatically start next round after a pause if host
                    if (isHost) {
                        setTimeout(() => this.startNextRound(), 5000);
                    }
                }
            }

            renderPlayerList() {
                const container = document.getElementById('player-list');
                const lobbyContainer = document.getElementById('lobby-player-list');
                container.innerHTML = '';
                lobbyContainer.innerHTML = '';

                this.players.forEach(p => {
                    const isCurrentDrawer = p.userId === this.gameData.drawerId;
                    const item = `<li class="flex items-center justify-between p-2 border-b last:border-b-0">
                                    <span class="text-xl mr-2">${p.avatar}</span>
                                    <span class="font-semibold truncate flex-grow">${p.name} ${p.isHost ? '(Host)' : ''}</span>
                                    <span class="font-bold text-lg text-blue-600 ml-2">${p.score} pts</span>
                                    ${isCurrentDrawer ? '<span class="text-sm bg-yellow-200 text-yellow-800 p-1 rounded-full">DRAWING</span>' : ''}
                                  </li>`;
                    container.innerHTML += item;
                    lobbyContainer.innerHTML += `<li class="p-2">${p.avatar} ${p.name}</li>`;
                });

                document.getElementById('lobby-player-count').textContent = `Players: ${this.players.length}/30`;
            }

            // --- 5. HOST ACTIONS ---

            async startGame() {
                if (this.players.length < 2) {
                    this.displayError("You need at least two players to start the game.");
                    return;
                }
                if (!this.isHost) return;

                // Start the first round
                await this.startNextRound();
            }

            async stopGame() {
                if (!this.isHost) return;
                try {
                    // 1. Update game status
                    await updateDoc(doc(db, `artifacts/${appId}/public/data/games`, this.gameId), {
                        status: 'FINISHED',
                        drawerId: null,
                        correctTerm: null,
                        timerStart: null,
                    });

                    // 2. Clear all related data (Drawings, Guesses, Players) for a clean slate
                    const playerPromises = this.players.map(p =>
                        deleteDoc(doc(db, `artifacts/${appId}/public/data/players`, p.userId))
                    );

                    const drawingsRef = doc(db, `artifacts/${appId}/public/data/drawings`, this.gameId);
                    await deleteDoc(drawingsRef).catch(e => console.log("No drawings to delete:", e));

                    // Guesses collection is handled by round, so clearing player/game is enough

                    await Promise.all(playerPromises);
                    this.displayError("Game successfully closed.");
                    this.resetToStartScreen();

                } catch (e) {
                    console.error("Error stopping game:", e);
                    this.displayError("Failed to stop game gracefully.");
                }
            }

            async startNextRound() {
                if (!this.isHost) return;

                // 1. Get the list of non-host players
                const studentPlayers = this.players.filter(p => !p.isHost);
                if (studentPlayers.length === 0) return;

                // 2. Determine the next drawer
                const currentDrawerId = this.gameData.drawerId;
                let nextDrawer;

                if (!currentDrawerId) {
                    // First round: pick a random student
                    nextDrawer = studentPlayers[Math.floor(Math.random() * studentPlayers.length)];
                } else {
                    // Subsequent rounds: cycle to the next player in the current list
                    const currentIndex = studentPlayers.findIndex(p => p.userId === currentDrawerId);
                    const nextIndex = (currentIndex + 1) % studentPlayers.length;
                    nextDrawer = studentPlayers[nextIndex];
                }

                // 3. Clear drawing history for the new round
                await setDoc(doc(db, `artifacts/${appId}/public/data/drawings`, this.gameId), { history: [] });

                // 4. Update game state to start a new round
                await updateDoc(doc(db, `artifacts/${appId}/public/data/games`, this.gameId), {
                    status: 'IN_PROGRESS',
                    currentRound: (this.gameData.currentRound || 0) + 1,
                    drawerId: nextDrawer.userId,
                    correctTerm: null, // Drawer needs to select this
                    timerStart: null,
                });

                console.log(`Starting round ${this.gameData.currentRound + 1}. Drawer: ${nextDrawer.name}`);
            }

            // Host side: called on correct guess or timeout
            async handleRoundEnd(timeRemaining) {
                if (!this.isHost) return;

                // Check if already ended
                if (this.gameData.status === 'ROUND_END') return;

                // 1. Update Game Status
                await updateDoc(doc(db, `artifacts/${appId}/public/data/games`, this.gameId), {
                    status: 'ROUND_END',
                });

                // If timeRemaining > 0, it means a correct guess happened, scores were updated in submitGuess
                // If timeRemaining == 0, it means a timeout, no points awarded.
            }


            // --- 6. DRAWING LOGIC (Drawer only) ---

            setupCanvas() {
                this.canvas = document.getElementById('game-canvas');
                this.ctx = this.canvas.getContext('2d');
                // Ensure canvas size is set based on container
                this.resizeCanvas();
                window.addEventListener('resize', () => this.resizeCanvas());

                // Set up tool selection listeners
                document.querySelectorAll('.tool-btn').forEach(btn => {
                    btn.addEventListener('click', () => {
                        this.toolColor = btn.dataset.color || '#000000';
                        this.toolSize = parseInt(btn.dataset.size || '5', 10);
                        document.querySelectorAll('.tool-btn').forEach(b => b.classList.remove('bg-gray-300'));
                        btn.classList.add('bg-gray-300');
                    });
                });
                document.getElementById('clear-canvas-btn').addEventListener('click', () => this.clearCanvas());

                // Drawing event listeners
                this.canvas.addEventListener('mousedown', (e) => this.startDrawing(e));
                this.canvas.addEventListener('mousemove', (e) => this.draw(e));
                this.canvas.addEventListener('mouseup', () => this.stopDrawing());
                this.canvas.addEventListener('mouseout', () => this.stopDrawing());

                // Touch events for mobile
                this.canvas.addEventListener('touchstart', (e) => this.startDrawing(e.touches[0]));
                this.canvas.addEventListener('touchmove', (e) => { e.preventDefault(); this.draw(e.touches[0]); }, { passive: false });
                this.canvas.addEventListener('touchend', () => this.stopDrawing());

                this.redrawCanvas(); // Initial clear/draw
            }

            resizeCanvas() {
                const container = this.canvas.parentElement;
                this.canvas.width = container.clientWidth;
                this.canvas.height = container.clientHeight;
                this.redrawCanvas();
            }

            startDrawing(e) {
                if (this.gameData.drawerId !== userId || !this.gameData.correctTerm || !this.gameData.timerStart) return;

                this.isDrawing = true;
                const rect = this.canvas.getBoundingClientRect();
                const x = e.clientX - rect.left;
                const y = e.clientY - rect.top;

                this.currentStroke = [{ x, y }];
                this.ctx.beginPath();
                this.ctx.moveTo(x, y);
            }

            draw(e) {
                if (!this.isDrawing) return;
                const rect = this.canvas.getBoundingClientRect();
                const x = e.clientX - rect.left;
                const y = e.clientY - rect.top;

                this.ctx.lineTo(x, y);
                this.ctx.lineWidth = this.toolSize;
                this.ctx.strokeStyle = this.toolColor;
                this.ctx.lineCap = 'round';
                this.ctx.stroke();

                this.currentStroke.push({ x, y });
            }

            async stopDrawing() {
                if (!this.isDrawing) return;
                this.isDrawing = false;
                this.ctx.closePath();

                if (this.currentStroke.length > 1) {
                    const newStroke = {
                        points: this.currentStroke,
                        color: this.toolColor,
                        size: this.toolSize
                    };

                    this.drawingHistory.push(newStroke);

                    // Update drawing history in Firestore
                    await setDoc(doc(db, `artifacts/${appId}/public/data/drawings`, this.gameId), {
                        history: this.drawingHistory
                    }, { merge: true });
                }
                this.currentStroke = [];
            }

            redrawCanvas() {
                if (!this.ctx) return;
                this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);

                this.drawingHistory.forEach(stroke => {
                    if (stroke.points && stroke.points.length > 0) {
                        this.ctx.beginPath();
                        this.ctx.moveTo(stroke.points[0].x, stroke.points[0].y);
                        this.ctx.lineWidth = stroke.size;
                        this.ctx.strokeStyle = stroke.color;
                        this.ctx.lineCap = 'round';

                        for (let i = 1; i < stroke.points.length; i++) {
                            this.ctx.lineTo(stroke.points[i].x, stroke.points[i].y);
                        }
                        this.ctx.stroke();
                        this.ctx.closePath();
                    }
                });
            }

            async clearCanvas() {
                if (this.gameData.drawerId !== userId) return;
                this.drawingHistory = [];
                this.redrawCanvas();
                await setDoc(doc(db, `artifacts/${appId}/public/data/drawings`, this.gameId), { history: [] });
            }


            // --- 7. GUESSING LOGIC (Guesser only) ---

            async submitGuess() {
                if (this.gameData.drawerId === userId || this.gameData.status !== 'IN_PROGRESS') return;
                const guessInput = document.getElementById('guess-input');
                const rawGuess = guessInput.value.trim();
                if (!rawGuess) return;

                const guess = rawGuess.toLowerCase().replace(/[^a-z0-9]/g, '');
                const correctTerm = this.gameData.correctTerm.toLowerCase().replace(/[^a-z0-9]/g, '');

                const guessRef = collection(db, `artifacts/${appId}/public/data/guesses`);
                const timestamp = Date.now();

                // 1. Log the guess (always log, even if incorrect)
                await addDoc(guessRef, {
                    gameId: this.gameId,
                    round: this.gameData.currentRound,
                    userId: userId,
                    name: this.playerName,
                    guess: rawGuess,
                    timestamp: timestamp,
                    isCorrect: (guess === correctTerm)
                });

                // 2. Check for correct answer
                if (guess === correctTerm && !this.guessAttempted) {
                    this.guessAttempted = true; // Block subsequent correct guesses
                    const timeElapsed = Math.floor((Date.now() - this.gameData.timerStart) / 1000);
                    const score = Math.max(1, 30 - timeElapsed); // Points = seconds remaining (min 1)

                    const drawer = this.players.find(p => p.userId === this.gameData.drawerId);
                    const guesser = this.players.find(p => p.userId === userId);

                    if (drawer && guesser) {
                        // Award points to the drawer and the guesser
                        await updateDoc(doc(db, `artifacts/${appId}/public/data/players`, drawer.userId), {
                            score: drawer.score + score
                        });
                        await updateDoc(doc(db, `artifacts/${appId}/public/data/players`, guesser.userId), {
                            score: guesser.score + score
                        });

                        // Notify all players that the term was guessed
                        await addDoc(guessRef, {
                            gameId: this.gameId,
                            round: this.gameData.currentRound,
                            userId: 'SYSTEM',
                            name: 'SYSTEM',
                            guess: `${guesser.name} correctly guessed the term! (${this.gameData.correctTerm}) They both earn ${score} points!`,
                            timestamp: Date.now(),
                            isCorrect: true // System message
                        });

                        // Host ends the round
                        if (this.isHost) {
                            this.handleRoundEnd(score);
                        }
                    }
                }

                guessInput.value = ''; // Clear the input
            }

            renderChat(guesses) {
                const chatBox = document.getElementById('chat-box');
                chatBox.innerHTML = ''; // Clear chat

                guesses.sort((a, b) => a.timestamp - b.timestamp);

                guesses.forEach(g => {
                    const isSystem = g.userId === 'SYSTEM';
                    const isMe = g.userId === userId && !isSystem;

                    let chatClass = 'text-gray-700';
                    if (isSystem) {
                        chatClass = 'font-bold text-green-600 bg-green-100 p-1 rounded-md';
                    } else if (g.isCorrect) {
                        chatClass = 'font-bold text-emerald-600';
                    } else if (isMe) {
                        chatClass = 'text-blue-600';
                    }

                    const nameDisplay = isSystem ? '' : `<span class="font-semibold">${g.name}: </span>`;
                    const guessText = `<p class="${chatClass}">${nameDisplay}${g.guess}</p>`;
                    chatBox.innerHTML += guessText;
                });

                // Scroll to bottom
                chatBox.scrollTop = chatBox.scrollHeight;
            }

            // --- 8. TERM SELECTION (Drawer only) ---

            showTermSelectionModal() {
                if (this.gameData.drawerId !== userId || this.gameData.correctTerm) return;

                const termOptions = [];
                while (termOptions.length < 3) {
                    const randomIndex = Math.floor(Math.random() * VCE_TERMS.length);
                    const term = VCE_TERMS[randomIndex];
                    if (!termOptions.includes(term)) {
                        termOptions.push(term);
                    }
                }

                const container = document.getElementById('term-options');
                container.innerHTML = '';

                termOptions.forEach(term => {
                    const button = document.createElement('button');
                    button.textContent = term;
                    button.className = 'btn-secondary w-full mb-3';
                    button.onclick = () => this.selectTerm(term);
                    container.appendChild(button);
                });

                document.getElementById('term-selection-modal').classList.remove('hidden');
            }

            async selectTerm(term) {
                if (this.gameData.drawerId !== userId || this.gameData.correctTerm) return;

                document.getElementById('term-selection-modal').classList.add('hidden');

                // Start the round
                await updateDoc(doc(db, `artifacts/${appId}/public/data/games`, this.gameId), {
                    correctTerm: term,
                    timerStart: Date.now()
                });

                // Clear the canvas immediately for the drawer
                this.clearCanvas();
            }

            // --- 9. UTILITY ---

            resetToStartScreen() {
                // Clear state and listeners
                this.gameId = '';
                this.gameData = {};
                this.players = [];
                this.drawingHistory = [];
                if (this.guessUnsubscribe) this.guessUnsubscribe();
                if (this.drawingUnsubscribe) this.drawingUnsubscribe();
                if (this.gameUnsubscribe) this.gameUnsubscribe();
                if (this.playersUnsubscribe) this.playersUnsubscribe();
                clearInterval(this.timerInterval);

                // Show start screen
                document.getElementById('start-screen').style.display = 'block';
                document.getElementById('lobby-setup-screen').style.display = 'none';
                document.getElementById('lobby-screen').style.display = 'none';
                document.getElementById('game-screen').style.display = 'none';
                
                // Re-disable buttons until auth confirms ready again (though it should be immediate now)
                document.getElementById('host-btn').disabled = true;
                document.getElementById('join-btn').disabled = true;
                document.getElementById('player-auth-status').classList.remove('text-green-600', 'font-semibold', 'text-red-500');
                document.getElementById('player-auth-status').classList.add('text-gray-500');
                document.getElementById('player-auth-status').textContent = 'Connecting...';
            }
        }

        window.onload = () => {
            window.pictionaryApp = new PictionaryApp();
        };
    </script>

    <!-- Error Message Display -->
    <div id="error-message" class="hidden fixed top-0 left-1/2 -translate-x-1/2 mt-4 p-3 bg-red-500 text-white font-bold rounded-lg shadow-xl z-50"></div>

    <!-- 1. Start Screen -->
    <div id="start-screen" class="max-w-xl mx-auto p-6 bg-white rounded-xl shadow-2xl text-center">
        <h1 class="text-4xl font-extrabold text-blue-600 mb-2">VCE Legal Pictionary</h1>
        <p class="text-gray-600 mb-8">Revision Game for Units 3 & 4 Key Terms & Cases</p>
        <div class="space-y-4">
            <button id="host-btn" class="btn-primary w-full text-xl py-3" disabled>
                Teacher: Create Game
            </button>
            <button id="join-btn" class="btn-secondary w-full text-xl py-3" disabled>
                Student: Join Game
            </button>
        </div>
        <p id="player-auth-status" class="mt-4 text-sm text-gray-500">Connecting...</p>
    </div>

    <!-- 2. Lobby Setup Screen -->
    <div id="lobby-setup-screen" class="hidden max-w-lg mx-auto p-8 bg-white rounded-xl shadow-2xl">
        <h2 id="setup-title" class="text-3xl font-bold text-gray-800 mb-6 text-center">Setup</h2>

        <div class="mb-6">
            <label for="player-name-input" class="block text-gray-700 font-semibold mb-2">Your Name</label>
            <input type="text" id="player-name-input" placeholder="Enter your name" class="w-full p-3 border border-gray-300 rounded-lg focus:ring-blue-500 focus:border-blue-500" maxlength="20">
        </div>

        <div class="mb-6">
            <label for="game-id-input" class="block text-gray-700 font-semibold mb-2">Game ID</label>
            <input type="text" id="game-id-input" placeholder="Enter Game ID" class="w-full p-3 border border-gray-300 rounded-lg focus:ring-blue-500 focus:border-blue-500 uppercase" maxlength="10">
        </div>

        <div class="mb-8">
            <h3 class="block text-gray-700 font-semibold mb-3">Select Avatar</h3>
            <div id="avatar-selection" class="flex justify-around items-center flex-wrap">
                <!-- Avatars rendered by JS -->
            </div>
        </div>

        <div class="flex flex-col space-y-4">
            <button id="create-join-btn" class="btn-primary w-full py-3">Join Lobby</button>
            <button id="setup-back-btn" class="text-gray-500 hover:text-gray-800 transition">Back to Main Menu</button>
        </div>
    </div>

    <!-- 3. Lobby Screen (Waiting Area) -->
    <div id="lobby-screen" class="hidden max-w-3xl mx-auto p-8 bg-white rounded-xl shadow-2xl">
        <h2 class="text-3xl font-bold text-gray-800 mb-4">Game Lobby</h2>
        <div class="flex justify-between items-center mb-6 border-b pb-4">
            <p class="text-xl text-gray-600">Game ID: <code id="lobby-game-id" class="font-mono bg-yellow-200 text-yellow-800 px-2 py-1 rounded-md"></code></p>
            <p id="lobby-player-count" class="text-lg text-blue-600 font-semibold">Players: 0/30</p>
        </div>

        <div id="host-controls" class="hidden mb-6 bg-blue-50 p-4 rounded-lg border-l-4 border-blue-400">
            <h3 class="text-xl font-semibold mb-2 text-blue-700">Teacher Host Controls</h3>
            <p class="text-gray-600 mb-4">Share the Game ID above with your students to let them join.</p>
            <button id="start-game-btn" class="btn-secondary" onclick="window.pictionaryApp.startGame()">Start Game</button>
        </div>

        <div id="student-info" class="hidden mb-6 bg-emerald-50 p-4 rounded-lg border-l-4 border-emerald-400">
            <h3 class="text-xl font-semibold text-emerald-700">Waiting for Teacher...</h3>
            <p class="text-gray-600">Once the teacher has started the game, you will automatically be moved to the game screen.</p>
        </div>

        <h3 class="text-2xl font-bold text-gray-800 mb-4">Current Players:</h3>
        <ul id="lobby-player-list" class="max-h-60 overflow-y-auto space-y-2">
            <!-- Player list rendered by JS -->
        </ul>
    </div>

    <!-- 4. Game Screen -->
    <div id="game-screen" class="hidden max-w-7xl mx-auto grid grid-cols-1 lg:grid-cols-4 gap-6">

        <!-- Column 1 & 2: Main Game Area (Canvas) -->
        <div class="lg:col-span-3 bg-white p-6 rounded-xl shadow-2xl h-[calc(100vh-10rem)] flex flex-col">
            <div class="flex justify-between items-center mb-4 pb-2 border-b">
                <h3 id="drawer-term" class="text-2xl font-bold text-gray-800">Waiting for Drawer...</h3>
                <button id="select-term-btn" class="btn-secondary hidden" style="font-size: 0.9rem;">Select Term</button>
                <div id="timer-display" class="text-3xl font-extrabold text-gray-500">Timer</div>
            </div>

            <!-- Canvas Drawing Area -->
            <div class="flex-grow canvas-container mb-4">
                <canvas id="game-canvas"></canvas>
            </div>

            <!-- Drawing Tools (Visible to Drawer only) -->
            <div id="drawing-tools" class="hidden flex justify-center space-x-2 p-2 bg-gray-50 rounded-lg shadow-inner border border-gray-200">
                <div class="flex space-x-1">
                    <button class="tool-btn bg-black data-color" data-color="#000000" data-size="5"></button>
                    <button class="tool-btn bg-red-500 data-color" data-color="#ef4444" data-size="5"></button>
                    <button class="tool-btn bg-blue-500 data-color" data-color="#3b82f6" data-size="5"></button>
                    <button class="tool-btn bg-green-500 data-color" data-color="#10b981" data-size="5"></button>
                </div>
                <div class="flex space-x-2 border-l pl-2">
                    <button class="tool-btn bg-black p-3 rounded-full data-size" data-color="#000000" data-size="5">S</button>
                    <button class="tool-btn bg-black p-3 rounded-full data-size" data-color="#000000" data-size="10">M</button>
                    <button class="tool-btn bg-black p-3 rounded-full data-size" data-color="#000000" data-size="15">L</button>
                </div>
                <button id="clear-canvas-btn" class="bg-red-500 text-white p-2 rounded-lg hover:bg-red-600 transition">Clear</button>
            </div>
        </div>

        <!-- Column 3: Scoreboard and Chat -->
        <div class="lg:col-span-1 flex flex-col space-y-6">

            <!-- Scoreboard -->
            <div class="bg-white p-4 rounded-xl shadow-md flex-none">
                <h3 class="text-xl font-bold text-gray-800 border-b pb-2 mb-2">Scoreboard</h3>
                <p class="text-sm text-gray-500 mb-2">Drawer: <span id="game-info-drawer" class="font-semibold">...</span> | Round: <span id="game-info-round" class="font-semibold">0</span></p>
                <ul id="player-list" class="max-h-56 overflow-y-auto">
                    <!-- Players rendered by JS -->
                </ul>
            </div>

            <!-- Chat / Guessing Area -->
            <div class="bg-white p-4 rounded-xl shadow-md flex-grow flex flex-col min-h-64">
                <h3 class="text-xl font-bold text-gray-800 border-b pb-2 mb-2">Guesses (Chat)</h3>
                <div id="chat-box" class="flex-grow overflow-y-auto space-y-1 mb-4 text-sm">
                    <!-- Guesses rendered by JS -->
                </div>

                <div id="guessing-area" class="flex space-x-2 flex-none">
                    <input type="text" id="guess-input" placeholder="Type your guess here..." class="flex-grow p-2 border border-gray-300 rounded-lg focus:ring-emerald-500 focus:border-emerald-500">
                    <button id="guess-btn" class="bg-emerald-500 text-white p-2 rounded-lg hover:bg-emerald-600 transition">Guess</button>
                </div>

                <p id="guess-info" class="text-xs text-gray-500 mt-2">First correct guess wins the round!</p>
            </div>

            <!-- Host Controls -->
            <div id="host-game-controls" class="hidden bg-red-100 p-3 rounded-lg border-l-4 border-red-400">
                <h4 class="font-semibold text-red-700">Game Manager</h4>
                <button id="stop-game-btn" class="bg-red-500 text-white p-2 rounded-lg hover:bg-red-600 transition mt-2 w-full">Stop Game (End Session)</button>
            </div>
        </div>
    </div>

    <!-- Modal for Term Selection (Drawer only) -->
    <div id="term-selection-modal" class="hidden fixed inset-0 bg-black bg-opacity-50 z-50 flex items-center justify-center">
        <div class="bg-white p-8 rounded-xl shadow-2xl max-w-md w-full text-center">
            <h3 class="text-2xl font-bold text-blue-600 mb-4">Choose a Term to Draw</h3>
            <p class="text-gray-600 mb-6">Select the term you feel most confident drawing in 30 seconds.</p>
            <div id="term-options" class="space-y-3">
                <!-- Buttons rendered by JS -->
            </div>
        </div>
    </div>
</body>
</html>
