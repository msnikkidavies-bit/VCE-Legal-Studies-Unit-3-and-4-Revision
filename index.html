<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>VCE Legal Pictionary Revision</title>
    <!-- Load Tailwind CSS for modern styling -->
    <script src="https://cdn.tailwindcss.com"></script>
    <!-- Use Inter Font -->
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;600;700&display=swap" rel="stylesheet">
    <style>
        :root {
            --primary-color: #3b82f6; /* blue-500 */
            --secondary-color: #10b981; /* emerald-500 */
            font-family: 'Inter', sans-serif;
        }
        .canvas-container {
            border: 4px solid var(--primary-color);
            border-radius: 12px;
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.1);
            background-color: white;
            cursor: crosshair;
        }
        #game-canvas {
            display: block;
            width: 100%;
            height: 100%;
        }
        .btn-primary {
            @apply bg-blue-600 text-white font-bold py-2 px-4 rounded-lg shadow-lg hover:bg-blue-700 transition duration-150 ease-in-out;
        }
        .btn-secondary {
            @apply bg-emerald-500 text-white font-bold py-2 px-4 rounded-lg shadow-lg hover:bg-emerald-600 transition duration-150 ease-in-out;
        }
        .avatar-selected {
            box-shadow: 0 0 0 3px var(--secondary-color);
        }
    </style>
</head>
<body class="bg-gray-100 min-h-screen p-4 sm:p-8">

    <!-- Firebase SDK Imports -->
    <script type="module">
        import { initializeApp } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-app.js";
        import { getAuth, signInAnonymously, signInWithCustomToken, onAuthStateChanged } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-auth.js";
        import { getFirestore, doc, getDoc, setDoc, updateDoc, onSnapshot, collection, query, limit, arrayUnion, arrayRemove, getDocs, deleteDoc, where } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-firestore.js";

        // Global Firebase variables (MUST be defined/used as per platform constraints)
        const appId = typeof __app_id !== 'undefined' ? __app_id : 'default-app-id';
        const firebaseConfig = typeof __firebase_config !== 'undefined' ? JSON.parse(__firebase_config) : null;
        const initialAuthToken = typeof __initial_auth_token !== 'undefined' ? __initial_auth_token : null;

        let app, db, auth;
        let userId = 'loading'; // Will be updated on auth state change

        // ----------------------------------------------------------------------
        // VCE Legal Pictionary Terms (Units 3 & 4)
        // ----------------------------------------------------------------------
        const VCE_TERMS = [
            // Key Concepts
            "Separation of Powers", "Division of Powers", "Bicameral Parliament",
            "Rule of Law", "Ultra Vires", "Referendum", "Representative Government",
            // Courts and Law-Making
            "Statutory Interpretation", "Delegated Legislation", "Judicial Precedent",
            "Ratio Decidendi", "Obiter Dicta", "Stare Decisis", "Court Hierarchy",
            // Criminal Law
            "Standard of Proof", "Burden of Proof", "Beyond Reasonable Doubt",
            "Mandatory Sentencing", "Original Jurisdiction", "Appellate Jurisdiction",
            "Plea Bargaining", "Bail", "Committal Hearing",
            // Civil Law
            "Balance of Probabilities", "Remedies", "Damages", "Injunction",
            "Mediation", "Conciliation", "Arbitration", "Vcat",
            // Cases (simplified for drawing)
            "Mabo Case (Native Title)", "Dietrich v The Queen (Legal Aid)",
            "Donoghue v Stevenson (Negligence)", "Snail in a bottle",
            "High Court of Australia", "Supreme Court of Victoria",
            "Jury Duty", "Indictable Offence", "Summary Offence",
        ];

        // ----------------------------------------------------------------------
        // GAME CLASS
        // ----------------------------------------------------------------------
        class PictionaryApp {
            constructor() {
                this.isHost = false;
                this.gameId = '';
                this.playerName = '';
                this.playerAvatar = '';
                this.gameData = {}; // Real-time game state from Firestore
                this.players = []; // Real-time player list from Firestore

                this.isDrawing = false;
                this.canvas = null;
                this.ctx = null;
                this.drawingHistory = []; // Local array to store drawing history
                this.currentStroke = [];
                this.toolSize = 5;
                this.toolColor = '#000000';
                this.guessAttempted = false; // Flag to prevent multiple successful guesses
                this.setupUI();
                this.setupFirebase();
            }

            // --- 1. SETUP ---

            setupUI() {
                document.getElementById('start-screen').style.display = 'block';
                document.getElementById('lobby-screen').style.display = 'none';
                document.getElementById('game-screen').style.display = 'none';

                // Initial Screen Event Listeners
                document.getElementById('host-btn').addEventListener('click', () => this.showLobbySetup(true));
                document.getElementById('join-btn').addEventListener('click', () => this.showLobbySetup(false));

                // Lobby Setup Screen Event Listeners
                document.getElementById('setup-back-btn').addEventListener('click', () => this.resetToStartScreen());
                document.getElementById('create-join-btn').addEventListener('click', () => this.handleLobbyAction());

                // Game Screen Event Listeners
                document.getElementById('guess-input').addEventListener('keypress', (e) => {
                    if (e.key === 'Enter') this.submitGuess();
                });
                document.getElementById('guess-btn').addEventListener('click', () => this.submitGuess());
                document.getElementById('select-term-btn').addEventListener('click', () => this.showTermSelectionModal());
                document.getElementById('stop-game-btn').addEventListener('click', () => this.stopGame());
                document.getElementById('player-role-display').textContent = 'Loading...';
            }

            async setupFirebase() {
                if (!firebaseConfig) {
                    console.error("Firebase config not available. Cannot initialize app.");
                    this.displayError("Configuration Error: Firebase settings are missing.");
                    return;
                }
                app = initializeApp(firebaseConfig);
                db = getFirestore(app);
                auth = getAuth(app);

                // Log level for debugging
                // setLogLevel('Debug');

                onAuthStateChanged(auth, async (user) => {
                    if (user) {
                        userId = user.uid;
                        document.getElementById('player-role-display').textContent = this.isHost ? 'Teacher (Host)' : 'Student (Player)';
                        console.log("Authenticated with UID:", userId);
                        // Once authenticated, check if they were in a game, or go to start screen.
                        if (this.gameId) {
                            await this.tryJoinGame(this.gameId);
                        }
                    } else {
                        // Sign in anonymously if no custom token is available
                        if (initialAuthToken) {
                            try {
                                await signInWithCustomToken(auth, initialAuthToken);
                            } catch (e) {
                                console.error("Error signing in with custom token:", e);
                                await signInAnonymously(auth);
                            }
                        } else {
                            await signInAnonymously(auth);
                        }
                    }
                });
            }

            displayError(message) {
                const errorDiv = document.getElementById('error-message');
                errorDiv.textContent = message;
                errorDiv.classList.remove('hidden');
                setTimeout(() => errorDiv.classList.add('hidden'), 5000);
            }

            // --- 2. LOBBY MANAGEMENT ---

            showLobbySetup(isHost) {
                this.isHost = isHost;
                document.getElementById('start-screen').style.display = 'none';
                document.getElementById('lobby-setup-screen').style.display = 'block';

                const roleText = isHost ? 'Create New Game' : 'Join Existing Game';
                document.getElementById('setup-title').textContent = roleText;
                document.getElementById('game-id-input').placeholder = isHost ? 'Auto-generated ID' : 'Enter Game ID';
                document.getElementById('game-id-input').disabled = isHost;
                document.getElementById('create-join-btn').textContent = isHost ? 'Create & Enter Lobby' : 'Join Lobby';
                document.getElementById('player-role-display').textContent = isHost ? 'Teacher (Host)' : 'Student (Player)';

                this.renderAvatarSelection();
            }

            renderAvatarSelection() {
                const avatars = ['🧑‍🏫', '🎓', '⚖️', '🏛️', '👨‍⚖️', '👩‍⚖️', '📚', '🧠'];
                const container = document.getElementById('avatar-selection');
                container.innerHTML = '';
                this.playerAvatar = avatars[0]; // Default avatar

                avatars.forEach(avatar => {
                    const button = document.createElement('button');
                    button.textContent = avatar;
                    button.className = `p-4 text-3xl rounded-full border-2 border-transparent hover:border-blue-500 transition duration-150 ${avatar === this.playerAvatar ? 'avatar-selected' : ''}`;
                    button.onclick = () => {
                        this.playerAvatar = avatar;
                        // Remove selection from all, add to this one
                        container.querySelectorAll('button').forEach(b => b.classList.remove('avatar-selected'));
                        button.classList.add('avatar-selected');
                    };
                    container.appendChild(button);
                });
            }

            async handleLobbyAction() {
                this.playerName = document.getElementById('player-name-input').value.trim();
                let gameIdInput = document.getElementById('game-id-input').value.trim();

                if (!this.playerName || !this.playerAvatar) {
                    this.displayError("Please enter your name and select an avatar.");
                    return;
                }

                if (this.isHost) {
                    await this.createGame();
                } else {
                    if (!gameIdInput) {
                        this.displayError("Please enter the Game ID to join.");
                        return;
                    }
                    this.gameId = gameIdInput;
                    await this.tryJoinGame(this.gameId);
                }
            }

            async createGame() {
                try {
                    // Create a new document in the 'games' collection to get an auto-generated ID
                    const gameRef = doc(collection(db, `artifacts/${appId}/public/data/games`));
                    this.gameId = gameRef.id;

                    await setDoc(gameRef, {
                        hostId: userId,
                        status: 'LOBBY',
                        currentRound: 0,
                        drawerId: null,
                        correctTerm: null,
                        timerStart: null,
                        maxScore: 0,
                    });

                    await this.tryJoinGame(this.gameId);

                } catch (e) {
                    console.error("Error creating game:", e);
                    this.displayError("Failed to create game. Please check console for details.");
                }
            }

            async tryJoinGame(gameId) {
                try {
                    const gameRef = doc(db, `artifacts/${appId}/public/data/games`, gameId);
                    const gameDoc = await getDoc(gameRef);

                    if (!gameDoc.exists()) {
                        this.displayError(`Game ID "${gameId}" not found.`);
                        this.resetToStartScreen();
                        return;
                    }

                    if (gameDoc.data().status !== 'LOBBY' && !this.isHost) {
                        this.displayError("Game has already started or finished. Cannot join.");
                        this.resetToStartScreen();
                        return;
                    }

                    const playerRef = doc(db, `artifacts/${appId}/public/data/players`, userId);

                    // Add player to the game
                    await setDoc(playerRef, {
                        userId: userId,
                        gameId: gameId,
                        name: this.playerName,
                        avatar: this.playerAvatar,
                        score: 0,
                        isHost: this.isHost,
                        lastActive: Date.now()
                    });

                    this.gameId = gameId;

                    // Transition to Lobby Screen
                    document.getElementById('lobby-setup-screen').style.display = 'none';
                    document.getElementById('lobby-screen').style.display = 'block';

                    document.getElementById('lobby-game-id').textContent = gameId;

                    // Set up Firestore listeners
                    this.listenToGame(gameRef);
                    this.listenToPlayers(gameId);

                    if (this.isHost) {
                        document.getElementById('host-controls').classList.remove('hidden');
                        document.getElementById('student-info').classList.add('hidden');
                    } else {
                        document.getElementById('host-controls').classList.add('hidden');
                        document.getElementById('student-info').classList.remove('hidden');
                    }

                } catch (e) {
                    console.error("Error joining game:", e);
                    this.displayError("Failed to join game. Check console.");
                }
            }

            // --- 3. FIREBASE LISTENERS ---

            listenToGame(gameRef) {
                onSnapshot(gameRef, (doc) => {
                    if (doc.exists()) {
                        this.gameData = doc.data();
                        this.updateGameUI();
                    } else {
                        // Game deleted by host
                        this.displayError("Game was closed by the host.");
                        this.resetToStartScreen();
                    }
                });
            }

            listenToPlayers(gameId) {
                const playersQuery = query(
                    collection(db, `artifacts/${appId}/public/data/players`),
                    where('gameId', '==', gameId)
                );

                onSnapshot(playersQuery, (snapshot) => {
                    this.players = [];
                    snapshot.forEach(doc => {
                        this.players.push(doc.data());
                    });
                    // Sort by score descending, then name ascending
                    this.players.sort((a, b) => b.score - a.score || a.name.localeCompare(b.name));
                    this.renderPlayerList();
                });
            }

            listenToGuesses() {
                const guessesQuery = query(
                    collection(db, `artifacts/${appId}/public/data/guesses`),
                    where('gameId', '==', this.gameId),
                    where('round', '==', this.gameData.currentRound)
                );

                // Clear previous listener if any
                if (this.guessUnsubscribe) this.guessUnsubscribe();

                this.guessUnsubscribe = onSnapshot(guessesQuery, (snapshot) => {
                    this.renderChat(snapshot.docs.map(doc => doc.data()));
                });
            }

            listenToDrawing() {
                const drawingRef = doc(db, `artifacts/${appId}/public/data/drawings`, this.gameId);

                // Clear previous listener if any
                if (this.drawingUnsubscribe) this.drawingUnsubscribe();

                this.drawingUnsubscribe = onSnapshot(drawingRef, (doc) => {
                    if (doc.exists() && doc.data().history) {
                        this.drawingHistory = doc.data().history;
                        this.redrawCanvas();
                    } else {
                        this.drawingHistory = [];
                        this.redrawCanvas();
                    }
                });
            }

            // --- 4. GAME LOGIC & UI UPDATES ---

            updateGameUI() {
                const { status, currentRound, drawerId, correctTerm, timerStart } = this.gameData;

                if (status === 'LOBBY') {
                    if (document.getElementById('game-screen').style.display !== 'none') {
                        document.getElementById('game-screen').style.display = 'none';
                        document.getElementById('lobby-screen').style.display = 'block';
                    }
                    return;
                }

                if (document.getElementById('lobby-screen').style.display !== 'none') {
                    document.getElementById('lobby-screen').style.display = 'none';
                    document.getElementById('game-screen').style.display = 'flex';
                    this.setupCanvas();
                    this.listenToDrawing();
                }

                const isDrawer = (drawerId === userId);
                const isHost = this.isHost;

                // --- General Game State UI ---
                document.getElementById('game-info-drawer').textContent = this.players.find(p => p.userId === drawerId)?.name || '...';
                document.getElementById('game-info-round').textContent = currentRound;

                // Set up controls visibility
                document.getElementById('drawing-tools').style.display = isDrawer ? 'flex' : 'none';
                document.getElementById('guessing-area').style.display = isDrawer ? 'none' : 'block';

                // --- Drawing Player specific UI ---
                if (isDrawer) {
                    document.getElementById('drawer-term').textContent = correctTerm ? `Drawing: ${correctTerm}` : 'Select a term to start!';
                    document.getElementById('select-term-btn').style.display = correctTerm ? 'none' : 'block';
                    document.getElementById('guess-info').style.display = 'none';
                } else {
                    // Guesser UI
                    document.getElementById('drawer-term').textContent = `Drawing: ${correctTerm ? Array(correctTerm.length).fill('_').join(' ') : '...'}`;
                    document.getElementById('guess-info').style.display = 'block';
                }

                // --- Host Control Visibility ---
                document.getElementById('host-game-controls').style.display = isHost ? 'block' : 'none';

                // --- Timer Management ---
                clearInterval(this.timerInterval);
                if (timerStart) {
                    this.timerInterval = setInterval(() => {
                        const elapsed = Math.floor((Date.now() - timerStart) / 1000);
                        const timeLeft = 30 - elapsed;
                        const timerDisplay = document.getElementById('timer-display');

                        if (timeLeft <= 0) {
                            clearInterval(this.timerInterval);
                            timerDisplay.textContent = 'Time Up!';
                            timerDisplay.classList.remove('text-green-600', 'text-yellow-600');
                            timerDisplay.classList.add('text-red-600');
                            if (isHost) this.handleRoundEnd(0);
                        } else {
                            timerDisplay.textContent = `Time: ${timeLeft}s`;
                            timerDisplay.classList.remove('text-red-600');
                            if (timeLeft > 15) {
                                timerDisplay.classList.add('text-green-600');
                                timerDisplay.classList.remove('text-yellow-600');
                            } else {
                                timerDisplay.classList.add('text-yellow-600');
                                timerDisplay.classList.remove('text-green-600');
                            }
                        }
                    }, 1000);

                    // Start listening to guesses once drawing starts
                    this.listenToGuesses();
                    this.guessAttempted = false; // Reset guess flag for new round

                } else if (status === 'IN_PROGRESS' && drawerId && !correctTerm) {
                    // Waiting for drawer to select a term
                    document.getElementById('timer-display').textContent = 'Awaiting selection...';
                } else if (status === 'ROUND_END') {
                    document.getElementById('timer-display').textContent = `Round ${currentRound} Ended! Term was: ${correctTerm}`;
                    document.getElementById('drawer-term').textContent = `The word was: ${correctTerm}`;
                    // Automatically start next round after a pause if host
                    if (isHost) {
                        setTimeout(() => this.startNextRound(), 5000);
                    }
                }
            }

            renderPlayerList() {
                const container = document.getElementById('player-list');
                const lobbyContainer = document.getElementById('lobby-player-list');
                container.innerHTML = '';
                lobbyContainer.innerHTML = '';

                this.players.forEach(p => {
                    const item = `<li class="flex items-center justify-between p-2 border-b last:border-b-0">
                                    <span class="text-xl mr-2">${p.avatar}</span>
                                    <span class="font-semibold truncate flex-grow">${p.name} ${p.isHost ? '(Host)' : ''}</span>
                                    <span class="font-bold text-lg text-blue-600 ml-2">${p.score} pts</span>
                                    ${p.userId === this.gameData.drawerId ? '<span class="text-sm bg-yellow-200 text-yellow-800 p-1 rounded-full">DRAWING</span>' : ''}
                                  </li>`;
                    container.innerHTML += item;
                    lobbyContainer.innerHTML += `<li class="p-2">${p.avatar} ${p.name}</li>`;
                });

                document.getElementById('lobby-player-count').textContent = `Players: ${this.players.length}/30`;
            }

            // --- 5. HOST ACTIONS ---

            async startGame() {
                if (this.players.length < 2) {
                    this.displayError("You need at least two players to start the game.");
                    return;
                }
                if (!this.isHost) return;

                // Start the first round
                await this.startNextRound();
            }

            async stopGame() {
                if (!this.isHost) return;
                try {
                    // 1. Update game status
                    await updateDoc(doc(db, `artifacts/${appId}/public/data/games`, this.gameId), {
                        status: 'FINISHED',
                        drawerId: null,
                        correctTerm: null,
                        timerStart: null,
                    });

                    // 2. Clear all related data (Drawings, Guesses, Players) for a clean slate
                    const playerPromises = this.players.map(p =>
                        deleteDoc(doc(db, `artifacts/${appId}/public/data/players`, p.userId))
                    );

                    const drawingsRef = doc(db, `artifacts/${appId}/public/data/drawings`, this.gameId);
                    await deleteDoc(drawingsRef).catch(e => console.log("No drawings to delete:", e));

                    // Guesses collection is handled by round, so clearing player/game is enough

                    await Promise.all(playerPromises);
                    this.displayError("Game successfully closed.");
                    this.resetToStartScreen();

                } catch (e) {
                    console.error("Error stopping game:", e);
                    this.displayError("Failed to stop game gracefully.");
                }
            }

            async startNextRound() {
                if (!this.isHost) return;

                // 1. Get the list of non-host players
                const studentPlayers = this.players.filter(p => !p.isHost);
                if (studentPlayers.length === 0) return;

                // 2. Determine the next drawer
                const currentDrawerId = this.gameData.drawerId;
                let nextDrawer;

                if (!currentDrawerId) {
                    // First round: pick a random student
                    nextDrawer = studentPlayers[Math.floor(Math.random() * studentPlayers.length)];
                } else {
                    // Subsequent rounds: cycle to the next player in the current list
                    const currentIndex = studentPlayers.findIndex(p => p.userId === currentDrawerId);
                    const nextIndex = (currentIndex + 1) % studentPlayers.length;
                    nextDrawer = studentPlayers[nextIndex];
                }

                // 3. Clear drawing history for the new round
                await setDoc(doc(db, `artifacts/${appId}/public/data/drawings`, this.gameId), { history: [] });

                // 4. Update game state to start a new round
                await updateDoc(doc(db, `artifacts/${appId}/public/data/games`, this.gameId), {
                    status: 'IN_PROGRESS',
                    currentRound: (this.gameData.currentRound || 0) + 1,
                    drawerId: nextDrawer.userId,
                    correctTerm: null, // Drawer needs to select this
                    timerStart: null,
                });

                console.log(`Starting round ${this.gameData.currentRound + 1}. Drawer: ${nextDrawer.name}`);
            }

            // Host side: called on correct guess or timeout
            async handleRoundEnd(timeRemaining) {
                if (!this.isHost) return;

                // Check if already ended
                if (this.gameData.status === 'ROUND_END') return;

                // 1. Update Game Status
                await updateDoc(doc(db, `artifacts/${appId}/public/data/games`, this.gameId), {
                    status: 'ROUND_END',
                });

                // If timeRemaining > 0, it means a correct guess happened, scores were updated in submitGuess
                // If timeRemaining == 0, it means a timeout, no points awarded.
            }


            // --- 6. DRAWING LOGIC (Drawer only) ---

            setupCanvas() {
                this.canvas = document.getElementById('game-canvas');
                this.ctx = this.canvas.getContext('2d');
                // Ensure canvas size is set based on container
                this.resizeCanvas();
                window.addEventListener('resize', () => this.resizeCanvas());

                // Set up tool selection listeners
                document.querySelectorAll('.tool-btn').forEach(btn => {
                    btn.addEventListener('click', () => {
                        this.toolColor = btn.dataset.color || '#000000';
                        this.toolSize = parseInt(btn.dataset.size || '5', 10);
                        document.querySelectorAll('.tool-btn').forEach(b => b.classList.remove('bg-gray-300'));
                        btn.classList.add('bg-gray-300');
                    });
                });
                document.getElementById('clear-canvas-btn').addEventListener('click', () => this.clearCanvas());

                // Drawing event listeners
                this.canvas.addEventListener('mousedown', (e) => this.startDrawing(e));
                this.canvas.addEventListener('mousemove', (e) => this.draw(e));
                this.canvas.addEventListener('mouseup', () => this.stopDrawing());
                this.canvas.addEventListener('mouseout', () => this.stopDrawing());

                // Touch events for mobile
                this.canvas.addEventListener('touchstart', (e) => this.startDrawing(e.touches[0]));
                this.canvas.addEventListener('touchmove', (e) => { e.preventDefault(); this.draw(e.touches[0]); }, { passive: false });
                this.canvas.addEventListener('touchend', () => this.stopDrawing());

                this.redrawCanvas(); // Initial clear/draw
            }

            resizeCanvas() {
                const container = this.canvas.parentElement;
                this.canvas.width = container.clientWidth;
                this.canvas.height = container.clientHeight;
                this.redrawCanvas();
            }

            startDrawing(e) {
                if (this.gameData.drawerId !== userId || !this.gameData.correctTerm || !this.gameData.timerStart) return;

                this.isDrawing = true;
                const rect = this.canvas.getBoundingClientRect();
                const x = e.clientX - rect.left;
                const y = e.clientY - rect.top;

                this.currentStroke = [{ x, y }];
                this.ctx.beginPath();
                this.ctx.moveTo(x, y);
            }

            draw(e) {
                if (!this.isDrawing) return;
                const rect = this.canvas.getBoundingClientRect();
                const x = e.clientX - rect.left;
                const y = e.clientY - rect.top;

                this.ctx.lineTo(x, y);
                this.ctx.lineWidth = this.toolSize;
                this.ctx.strokeStyle = this.toolColor;
                this.ctx.lineCap = 'round';
                this.ctx.stroke();

                this.currentStroke.push({ x, y });
            }

            async stopDrawing() {
                if (!this.isDrawing) return;
                this.isDrawing = false;
                this.ctx.closePath();

                if (this.currentStroke.length > 1) {
                    const newStroke = {
                        points: this.currentStroke,
                        color: this.toolColor,
                        size: this.toolSize
                    };

                    this.drawingHistory.push(newStroke);

                    // Update drawing history in Firestore
                    await setDoc(doc(db, `artifacts/${appId}/public/data/drawings`, this.gameId), {
                        history: this.drawingHistory
                    }, { merge: true });
                }
                this.currentStroke = [];
            }

            redrawCanvas() {
                if (!this.ctx) return;
                this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);

                this.drawingHistory.forEach(stroke => {
                    if (stroke.points && stroke.points.length > 0) {
                        this.ctx.beginPath();
                        this.ctx.moveTo(stroke.points[0].x, stroke.points[0].y);
                        this.ctx.lineWidth = stroke.size;
                        this.ctx.strokeStyle = stroke.color;
                        this.ctx.lineCap = 'round';

                        for (let i = 1; i < stroke.points.length; i++) {
                            this.ctx.lineTo(stroke.points[i].x, stroke.points[i].y);
                        }
                        this.ctx.stroke();
                        this.ctx.closePath();
                    }
                });
            }

            async clearCanvas() {
                if (this.gameData.drawerId !== userId) return;
                this.drawingHistory = [];
                this.redrawCanvas();
                await setDoc(doc(db, `artifacts/${appId}/public/data/drawings`, this.gameId), { history: [] });
            }


            // --- 7. GUESSING LOGIC (Guesser only) ---

            async submitGuess() {
                if (this.gameData.drawerId === userId || this.gameData.status !== 'IN_PROGRESS') return;
                const guessInput = document.getElementById('guess-input');
                const rawGuess = guessInput.value.trim();
                if (!rawGuess) return;

                const guess = rawGuess.toLowerCase().replace(/[^a-z0-9]/g, '');
                const correctTerm = this.gameData.correctTerm.toLowerCase().replace(/[^a-z0-9]/g, '');

                const guessRef = collection(db, `artifacts/${appId}/public/data/guesses`);
                const timestamp = Date.now();

                // 1. Log the guess (always log, even if incorrect)
                await addDoc(guessRef, {
                    gameId: this.gameId,
                    round: this.gameData.currentRound,
                    userId: userId,
                    name: this.playerName,
                    guess: rawGuess,
                    timestamp: timestamp,
                    isCorrect: (guess === correctTerm)
                });

                // 2. Check for correct answer
                if (guess === correctTerm && !this.guessAttempted) {
                    this.guessAttempted = true; // Block subsequent correct guesses
                    const timeElapsed = Math.floor((Date.now() - this.gameData.timerStart) / 1000);
                    const score = Math.max(1, 30 - timeElapsed); // Points = seconds remaining (min 1)

                    const drawer = this.players.find(p => p.userId === this.gameData.drawerId);
                    const guesser = this.players.find(p => p.userId === userId);

                    if (drawer && guesser) {
                        // Award points to the drawer and the guesser
                        await updateDoc(doc(db, `artifacts/${appId}/public/data/players`, drawer.userId), {
                            score: drawer.score + score
                        });
                        await updateDoc(doc(db, `artifacts/${appId}/public/data/players`, guesser.userId), {
                            score: guesser.score + score
                        });

                        // Notify all players that the term was guessed
                        await addDoc(guessRef, {
                            gameId: this.gameId,
                            round: this.gameData.currentRound,
                            userId: 'SYSTEM',
                            name: 'SYSTEM',
                            guess: `${guesser.name} correctly guessed the term! (${this.gameData.correctTerm}) They both earn ${score} points!`,
                            timestamp: Date.now(),
                            isCorrect: true // System message
                        });

                        // Host ends the round
                        if (this.isHost) {
                            this.handleRoundEnd(score);
                        }
                    }
                }

                guessInput.value = ''; // Clear the input
            }

            renderChat(guesses) {
                const chatBox = document.getElementById('chat-box');
                chatBox.innerHTML = ''; // Clear chat

                guesses.sort((a, b) => a.timestamp - b.timestamp);

                guesses.forEach(g => {
                    const isSystem = g.userId === 'SYSTEM';
                    const isMe = g.userId === userId && !isSystem;

                    let chatClass = 'text-gray-700';
                    if (isSystem) {
                        chatClass = 'font-bold text-green-600 bg-green-100 p-1 rounded-md';
                    } else if (g.isCorrect) {
                        chatClass = 'font-bold text-emerald-600';
                    } else if (isMe) {
                        chatClass = 'text-blue-600';
                    }

                    const nameDisplay = isSystem ? '' : `<span class="font-semibold">${g.name}: </span>`;
                    const guessText = `<p class="${chatClass}">${nameDisplay}${g.guess}</p>`;
                    chatBox.innerHTML += guessText;
                });

                // Scroll to bottom
                chatBox.scrollTop = chatBox.scrollHeight;
            }

            // --- 8. TERM SELECTION (Drawer only) ---

            showTermSelectionModal() {
                if (this.gameData.drawerId !== userId || this.gameData.correctTerm) return;

                const termOptions = [];
                while (termOptions.length < 3) {
                    const randomIndex = Math.floor(Math.random() * VCE_TERMS.length);
                    const term = VCE_TERMS[randomIndex];
                    if (!termOptions.includes(term)) {
                        termOptions.push(term);
                    }
                }

                const container = document.getElementById('term-options');
                container.innerHTML = '';

                termOptions.forEach(term => {
                    const button = document.createElement('button');
                    button.textContent = term;
                    button.className = 'btn-secondary w-full mb-3';
                    button.onclick = () => this.selectTerm(term);
                    container.appendChild(button);
                });

                document.getElementById('term-selection-modal').classList.remove('hidden');
            }

            async selectTerm(term) {
                if (this.gameData.drawerId !== userId || this.gameData.correctTerm) return;

                document.getElementById('term-selection-modal').classList.add('hidden');

                // Start the round
                await updateDoc(doc(db, `artifacts/${appId}/public/data/games`, this.gameId), {
                    correctTerm: term,
                    timerStart: Date.now()
                });

                // Clear the canvas immediately for the drawer
                this.clearCanvas();
            }

            // --- 9. UTILITY ---

            resetToStartScreen() {
                // Clear state and listeners
                this.gameId = '';
                this.gameData = {};
                this.players = [];
                this.drawingHistory = [];
                if (this.guessUnsubscribe) this.guessUnsubscribe();
                if (this.drawingUnsubscribe) this.drawingUnsubscribe();
                clearInterval(this.timerInterval);

                // Show start screen
                document.getElementById('start-screen').style.display = 'block';
                document.getElementById('lobby-setup-screen').style.display = 'none';
                document.getElementById('lobby-screen').style.display = 'none';
                document.getElementById('game-screen').style.display = 'none';
            }
        }

        window.onload = () => {
            window.pictionaryApp = new PictionaryApp();
        };
    </script>

    <!-- Error Message Display -->
    <div id="error-message" class="hidden fixed top-0 left-1/2 -translate-x-1/2 mt-4 p-3 bg-red-500 text-white font-bold rounded-lg shadow-xl z-50"></div>

    <!-- 1. Start Screen -->
    <div id="start-screen" class="max-w-xl mx-auto p-6 bg-white rounded-xl shadow-2xl text-center
